# 装饰模式(decorate)

## 定义：
动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式远比生成子类实现更加灵活。装饰模式是一种对象结构型模式。

## 结构：
* Component(抽象构件)：具体构件和抽象装饰类的基类，声明了再具体构件中需要实现的业务方法。
* ConcreteComponent(具体构件)：抽象构件的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责(方法)。
* Decorator(抽象装饰类)：他是抽象构件的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。
* ConcreteDecorator(具体装饰类)：抽象装饰类的子类，负责向构件添加新的职责。

## 优点：
* 对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧上升。
* 可以对一个对象进行多次装饰，从而创造出很多不同行为的组合，得到功能更强大的对象。
* 具体构件类和具体装饰类可以独立变化，可以根据具体需要增加新的具体构件和具体装饰，原有代码无需修改，符合开闭原则。

## 缺点：
* 虽然装饰模式提供了一种比继承更加灵活机动的方案，但同时也意味着比继承更容易出错，排错也很困难。
* 特别是经过多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。

## 应用场景：
* 在不影响其他对象的情况下，想要动态地、透明地给单个对象添加职责。
* 当不能采用继承的方式对系统进行扩展 或 采用继承不利于系统扩展和维护时。

## 个人总结：
* 通过购买奶茶的例子来理解装饰模式，顾客购买一杯奶茶，你需要给出对这个奶茶的描述和价格。如果不用装饰模式，那么我们会设计一个奶茶的父类，
带有最基本的描述和最基本的价格。其他种类的奶茶，如珍珠奶茶则会继承自这个父类，然后重写父类的方法，添加自己的描述和价格。遇到的问题有：
   * 如果出一个新品种的奶茶，就需要新加入一个类，那么有100种奶茶就有100个类
   * 如果需要加双份椰果的奶茶，怎么办？
   * 如果奶茶或调料的价格需要临时变动怎么办？
* 对于Component(抽象构件)来说，它是被装饰的基本单位，而ConcreteComponent(具体构件)则是它不同的表现形式。同样的，Decorator(抽象装饰)
是最基本的装饰单位，他声明每个ConcreteDecorator(具体装饰)需要做的事情。
* 构件只能被构建一次，而装饰可以多次。



